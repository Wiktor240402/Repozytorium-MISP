# -*- coding: utf-8 -*-
"""zad1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jfdavS_COEGj62kc1G_nVlGbxUQac0L1
"""

!pip install pulp
#!sudo apt-get install coinor-cbc glpk-utils coinor-clp

### kod sprawdza czy instalacja się udała
import pulp
#print(pulp.___version___)

pulp.pulpTestAll()

"""# Zadania:

1. przeczytaj materiały dotyczące pulp ze strony internetowej https://coin-or.github.io/pulp/main/index.html oraz przejdź przez blending problem (przepisz do swojego notebooka)

2. w blending problem dodaj zmienną decyzyjną. Stwórz zmienną która pojawi się w końcowym składzie produktu (tj. wartość zmiennej będzie miała niezerową postać)

3. Dodaj ograniczenie co do zawartości witaminy B

Zawartość:

| Nazwa      | zawartość ug/100g |
|------------|-------------------|
| chicken    | 0.3               |
| beef       | 2.6               |
| mutton     | 2.6               |
| rice       | 0                 |
| wheat bran | 0                 |
| gel        | 0                 |
| sardines   | 8.9               |

Kot ma zjeść minimum 0.24 ug na kilogram masy więc około
0.8 ug dziennie

4. Na końcu ma pojawiać się zdanie podsumowujące wynik, w stylu:
Końcowy produkt będzie kosztować {}, będzie miał w składzie {nazwa}: {} %, {nastepna nazwa}: {} %

Takie zdanie można skleić z części generowanych automatycznie:


"""

sklejone_produkt_cena = [":".join((produkt, str(cena))) for produkt,cena in zip(["jabłko","banan"],[5,10])]
print(sklejone_produkt_cena)
sklejona_calosc = ", ".join(sklejone_produkt_cena)

print(sklejona_calosc)

from pulp import *

from pulp import *

prob = LpProblem("Optymalizacja produkcji Marsów i Snickersów", LpMaximize)

orzechy = LpVariable("Orzechy", 0, 3000)
czekolada_mars = LpVariable("Czekolada_Mars", 0)
czekolada_snickers = LpVariable("Czekolada_Snickers", 0)

mars = LpVariable("Mars", 0)
snickers = LpVariable("Snickers", 0)

czekolada = czekolada_mars + czekolada_snickers

ceny = {
    "czekolada": 20,
    "karmel": 15,
    "orzechy": 20,
    "olej": 7,
    "cukier": 10
}

zysk_mars = 100
zysk_snickers = 150

prob += czekolada_mars == 0.5 * mars, "Zużycie czekolady przez Marsa"
prob += czekolada_snickers == 0.4 * snickers, "Zużycie czekolady przez Snickersa"
prob += orzechy == 0.2 * snickers, "Zużycie orzechów przez Snickersa"

prob += czekolada <= 6000, "Ograniczenie na czekoladę"
prob += orzechy <= 3000, "Ograniczenie na orzechy"
prob += mars + snickers <= 10000, "Ograniczenie na pakowanie"

koszt_mars = 0.5 * ceny["czekolada"] + 0.2 * ceny["karmel"] + 0.25 * ceny["cukier"] + 0.05 * ceny["olej"]
koszt_snickers = 0.4 * ceny["czekolada"] + 0.2 * ceny["orzechy"] + 0.2 * ceny["karmel"] + 0.05 * ceny["olej"] + 0.15 * ceny["cukier"]

prob += (zysk_mars * mars - koszt_mars * mars) + (zysk_snickers * snickers - koszt_snickers * snickers), "Maksymalizacja zysku netto"

prob.solve()

wynik_produkcji = []
for v in prob.variables():
    wynik_produkcji.append(f"{v.name}: {v.varValue:.2f} kg")

calkowity_zysk = value(prob.objective)

print(f"Maksymalny zysk netto wynosi {calkowity_zysk:.2f} zł.")
print(f"Optymalna ilość składników i produktów: {', '.join(wynik_produkcji)}.")

from pulp import *

# Tworzymy problem optymalizacji prądu
prob = LpProblem("Optymalizacja przepływu prądu", LpMaximize)

# Definicja zmiennych prądu przez rezystory, ograniczając maksymalny prąd na podstawie danych
I1 = LpVariable("I1", 0, 2)  # maksymalnie 2 A dla I1
I2 = LpVariable("I2", 0, 3)  # maksymalnie 3 A dla I2
I3 = LpVariable("I3", 0, 4)  # maksymalnie 4 A dla I3
I4 = LpVariable("I4", 0, 2)  # maksymalnie 2 A dla I4
I5 = LpVariable("I5", 0, 2)  # maksymalnie 2 A dla I5

# Definicja wartości rezystorów
R1, R2, R3, R4, R5 = 8, 6, 4, 10, 8  # Ohmy

# Dodajemy ograniczenia na podstawie połączeń równoległych i szeregowych
# R1 i R2 są równolegle, więc prądy przez R1 i R2 muszą być równe
prob += I1 * R1 == I2 * R2, "Prawo Kirchoffa dla R1 i R2 w równoległym połączeniu"

# Prąd przez R3 jest sumą prądów przez R1 i R2 (szeregowe połączenie za równoległym)
prob += I3 == I1 + I2, "Suma prądów dla R3"

# R4 i R5 są równolegle, więc prądy przez R4 i R5 muszą być równe
prob += I4 * R4 == I5 * R5, "Prawo Kirchoffa dla R4 i R5 w równoległym połączeniu"

# Maksymalny prąd przez układ jest sumą prądów przez R3 i przez równoległe R4 i R5
I_total = I4 + I5

# Dodajemy funkcję celu: maksymalizację prądu przez układ
prob += I_total, "Maksymalizacja prądu przez cały układ"

# Rozwiązujemy problem
prob.solve()

# Wyświetlenie wyników
print("Wyniki optymalizacji prądu w układzie:")
print(f"Maksymalny prąd przez układ wynosi {I_total.value():.2f} A.")

from pulp import *

# Tworzymy problem optymalizacji prądu z celem minimalizacji mocy
prob = LpProblem("Optymalizacja_mocy", LpMinimize)

# Definicja zmiennych prądu przez rezystory, ograniczając maksymalny prąd na podstawie danych
I1 = LpVariable("I1", 3, 5)  # zakres od 3 A do 5 A
I2 = LpVariable("I2", 1, 3)  # zakres od 1 A do 3 A
I3 = LpVariable("I3", 1, 3)  # zakres od 1 A do 3 A
I4 = LpVariable("I4", 1, 3)  # zakres od 1 A do 3 A
I5 = LpVariable("I5", 3, 5)  # zakres od 3 A do 5 A

# Stałe napięcia
U1, U2, U3, U4, U5 = 6, 10, 4, 7, 3  # napięcia w woltach

# Definicja zmiennych konduktancji (G = 1/R)
G1 = LpVariable("G1", 0.01, None)  # minimalna wartość konduktancji, aby uniknąć dzielenia przez zero
G2 = LpVariable("G2", 0.01, None)
G3 = LpVariable("G3", 0.01, None)
G4 = LpVariable("G4", 0.01, None)
G5 = LpVariable("G5", 0.01, None)

# Definicja zmiennych mocy
P1 = LpVariable("P1", 0, None)  # moc musi być nieujemna
P2 = LpVariable("P2", 0, None)
P3 = LpVariable("P3", 0, None)
P4 = LpVariable("P4", 0, None)
P5 = LpVariable("P5", 0, None)

# Ograniczenia z prawa Kirchoffa
prob += I1 == (I4 + I3), "Kirchoff_1_1"
prob += I2 == (I5 - I3), "Kirchoff_1_2"
prob += (I2 + I1) == (I4 + I5), "Kirchoff_1_3"

# Prawo Ohma: I = G * U
prob += I1 == (G1 * U1), "Ohm_G1"
prob += I2 == G2 * U2, "Ohm_G2"
prob += I3 == G3 * U3, "Ohm_G3"
prob += I4 == G4 * U4, "Ohm_G4"
prob += I5 == G5 * U5, "Ohm_G5"

# Moc na rezystorach (P = U * I)
prob += P1 == U1*U1*G1, "Power_R1"
prob += P2 == U2*U2*G2, "Power_R2"
prob += P3 == U3*U3*G3, "Power_R3"
prob += P4 == U4*U4*G4, "Power_R4"
prob += P5 == U5*U5*G5, "Power_R5"

# Całkowita moc
P_total = P1 + P2 + P3 + P4 + P5
prob += P_total, "Total_Power"

# Rozwiązujemy problem
prob.solve()

# Wyświetlenie wyników
print("Wyniki optymalizacji mocy:")
print(f"Minimalna moc: {value(P_total):.2f} mW.")

# Wyświetlanie wyników w mA
for var in prob.variables():
    if "I" in var.name:  # Dla zmiennych prądu (I1, I2, ...)
        print(f"{var.name} = {var.varValue:.2f} mA")  # Przemnóż przez 1000, aby uzyskać mA
    else:
        print(f"{var.name} = {var.varValue:.2f}")

from pulp import *

# Tworzymy problem minimalizacji kosztów
prob = LpProblem("Minimalizacja_kosztów", LpMinimize)

# Definicja zmiennych
godziny_piotra = LpVariable("Godziny_Piotra", 0, 20)  # Piotr może pracować maksymalnie 20h
godziny_barbary = LpVariable("Godziny_Barbary", 0, 80)  # Barbara może pracować maksymalnie 80h
godziny_zenona = LpVariable("Godziny_Zenona", 0, 50)  # Zenon może pracować maksymalnie 50h

# Stawki godzinowe
stawka_piotra = 30  # zł/h
stawka_barbary = 50  # zł/h
stawka_zenona = 40  # zł/h

# Ograniczenia
prob += godziny_piotra + godziny_barbary + godziny_zenona == 80, "Wymagany_czas_pracy"

# Funkcja kosztów
koszt = (godziny_piotra * stawka_piotra +
         godziny_barbary * stawka_barbary +
         godziny_zenona * stawka_zenona)
prob += koszt, "Minimalizacja_kosztów"

# Rozwiązanie problemu
prob.solve()

# Wyświetlenie wyników
print("Status:", LpStatus[prob.status])
print(f"Minimalny koszt: {value(prob.objective):.2f} zł")
print(f"Godziny pracy Piotra: {godziny_piotra.varValue:.2f} h")
print(f"Godziny pracy Barbary: {godziny_barbary.varValue:.2f} h")
print(f"Godziny pracy Zenona: {godziny_zenona.varValue:.2f} h")

from pulp import *

# Tworzymy problem minimalizacji kosztów
prob = LpProblem("Minimalizacja_kosztów", LpMinimize)

# Definicja dni tygodnia
dni_tygodnia = ["Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota", "Niedziela"]

# Definicja zmiennych dla godzin pracy każdego pracownika w poszczególne dni
godziny_piotra = {dzien: LpVariable(f"Godziny_Piotra_{dzien}", 0, 10 if dzien in ["Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek"] else 0) for dzien in dni_tygodnia}
godziny_barbary = {dzien: LpVariable(f"Godziny_Barbary_{dzien}", 0, 10) for dzien in dni_tygodnia}
godziny_zenona = {dzien: LpVariable(f"Godziny_Zenona_{dzien}", 0, 10 if dzien in ["Sobota", "Niedziela", "Poniedziałek", "Wtorek", "Środa"] else 0) for dzien in dni_tygodnia}

# Stawki godzinowe
stawka_piotra = 30  # zł/h
stawka_barbary = 50  # zł/h
stawka_zenona = 40  # zł/h

# Ograniczenia dzienne
for dzien in dni_tygodnia:
    if dzien == "Sobota":
        prob += godziny_piotra[dzien] + godziny_barbary[dzien] + godziny_zenona[dzien] == 20, f"Ograniczenie_dnia_{dzien}"
    else:
        prob += godziny_piotra[dzien] + godziny_barbary[dzien] + godziny_zenona[dzien] == 10, f"Ograniczenie_dnia_{dzien}"

# Ograniczenia tygodniowe dla każdego pracownika
prob += lpSum(godziny_piotra[dzien] for dzien in dni_tygodnia) <= 20, "Ograniczenie_tygodniowe_Piotra"
prob += lpSum(godziny_barbary[dzien] for dzien in dni_tygodnia) <= 80, "Ograniczenie_tygodniowe_Barbary"
prob += lpSum(godziny_zenona[dzien] for dzien in dni_tygodnia) <= 50, "Ograniczenie_tygodniowe_Zenona"

# Funkcja kosztów
koszt = lpSum(
    godziny_piotra[dzien] * stawka_piotra +
    godziny_barbary[dzien] * stawka_barbary +
    godziny_zenona[dzien] * stawka_zenona
    for dzien in dni_tygodnia
)
prob += koszt, "Minimalizacja_kosztów"

# Rozwiązanie problemu
prob.solve()

# Wyświetlenie wyników
print("Status:", LpStatus[prob.status])
print(f"Minimalny koszt: {value(prob.objective):.2f} zł")
print("Rozkład godzin pracy w poszczególne dni:")
for dzien in dni_tygodnia:
    print(f"\n{dzien}:")
    print(f"  Godziny pracy Piotra: {godziny_piotra[dzien].varValue:.2f} h")
    print(f"  Godziny pracy Barbary: {godziny_barbary[dzien].varValue:.2f} h")
    print(f"  Godziny pracy Zenona: {godziny_zenona[dzien].varValue:.2f} h")
print("\nPodsumowanie tygodniowe:")
print(f"  Łączne godziny pracy Piotra: {sum(godziny_piotra[dzien].varValue for dzien in dni_tygodnia):.2f} h")
print(f"  Łączne godziny pracy Barbary: {sum(godziny_barbary[dzien].varValue for dzien in dni_tygodnia):.2f} h")
print(f"  Łączne godziny pracy Zenona: {sum(godziny_zenona[dzien].varValue for dzien in dni_tygodnia):.2f} h")

from pulp import *

# Define the problem
prob = LpProblem("Optymalizacja inwestycji", LpMaximize)

# Define the variables
udzialy1 = LpVariable("Udzialy1", 0, 1)
udzialy2 = LpVariable("Udzialy2", 0, 1)
godziny_pracy = LpVariable("Godziny_pracy", 0, 100)

# Define the constraints
prob += 10000 * udzialy1 + 8000 * udzialy2 <= 20000, "Ograniczenie na inwestycje pieniężne"
prob += 400 * udzialy1 + 500 * udzialy2 + godziny_pracy <= 600, "Ograniczenie na czas"

# Define the objective function
prob += 9000 * udzialy1 + 9000 * udzialy2 + 50 * godziny_pracy, "Maksymalizacja zysku"

# Solve the problem
prob.solve()

# Get the results
wynik_udzialy1 = udzialy1.varValue
wynik_udzialy2 = udzialy2.varValue
wynik_godziny_pracy = godziny_pracy.varValue
calkowity_zysk = value(prob.objective)

print(f"Maksymalny zysk wynosi {calkowity_zysk:.2f} zł.")
print(f"Optymalne udziały u pierwszego kolegi: {wynik_udzialy1:.2f}")
print(f"Optymalne udziały u drugiego kolegi: {wynik_udzialy2:.2f}")
print(f"Optymalna liczba godzin pracy: {wynik_godziny_pracy:.2f}")